<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EigenOpt: EigenOpt::simplex::internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      bm: ["{\\boldsymbol{#1}}",1],
    }
    // packages: {'[+]': ['mathtools']}
  }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EigenOpt<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceEigenOpt_1_1simplex_1_1internal.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">EigenOpt::simplex::internal Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Utility functions used by the Simplex algorithm.  
<a href="namespaceEigenOpt_1_1simplex_1_1internal.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigenOpt_1_1simplex_1_1internal_1_1VariableDomain.html">VariableDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliay structure to store the domain of a variable.  <a href="structEigenOpt_1_1simplex_1_1internal_1_1VariableDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2d2a61a7c4ba3c3807109a931ed1aee3" id="r_a2d2a61a7c4ba3c3807109a931ed1aee3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </td></tr>
<tr class="memitem:a2d2a61a7c4ba3c3807109a931ed1aee3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a2d2a61a7c4ba3c3807109a931ed1aee3">deduce_variables_domains</a> (<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">C</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, 1 &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">d</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">small_number</a>, std::vector&lt; <a class="el" href="structEigenOpt_1_1simplex_1_1internal_1_1VariableDomain.html">VariableDomain</a> &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">domains</a>, std::string &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">halt_reason</a>)</td></tr>
<tr class="memdesc:a2d2a61a7c4ba3c3807109a931ed1aee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of inequality constraints, deduce the domain of the decision variables.  <br /></td></tr>
<tr class="separator:a2d2a61a7c4ba3c3807109a931ed1aee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023f64ee8724d3702a37a25cbac476e2" id="r_a023f64ee8724d3702a37a25cbac476e2"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:a023f64ee8724d3702a37a25cbac476e2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">transformation_matrix_from_domains</a> (const std::vector&lt; <a class="el" href="structEigenOpt_1_1simplex_1_1internal_1_1VariableDomain.html">VariableDomain</a> &gt; &amp;domains)</td></tr>
<tr class="memdesc:a023f64ee8724d3702a37a25cbac476e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a transformation matrix so that \(\bm{x}=\bm{T}\bm{w}\), \(w \geq 0\).  <br /></td></tr>
<tr class="separator:a023f64ee8724d3702a37a25cbac476e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c008fc16c1272793272a84be35eb851" id="r_a7c008fc16c1272793272a84be35eb851"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </td></tr>
<tr class="memitem:a7c008fc16c1272793272a84be35eb851"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a7c008fc16c1272793272a84be35eb851">transformation_matrix</a> (<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">C</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, 1 &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">d</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">small_number</a>, Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">T</a>, std::string &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">halt_reason</a>)</td></tr>
<tr class="memdesc:a7c008fc16c1272793272a84be35eb851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a transformation matrix so that \(\bm{x}=\bm{T}\bm{w}\), \(w \geq 0\).  <br /></td></tr>
<tr class="separator:a7c008fc16c1272793272a84be35eb851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d948c25bc5bbe0d1fac2a38b2650d62" id="r_a7d948c25bc5bbe0d1fac2a38b2650d62"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </td></tr>
<tr class="memitem:a7d948c25bc5bbe0d1fac2a38b2650d62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a7d948c25bc5bbe0d1fac2a38b2650d62">create_tableau</a> (<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">C</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, 1 &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">d</a>, Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">tableau</a>, std::vector&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">basic_variables</a>)</td></tr>
<tr class="memdesc:a7d948c25bc5bbe0d1fac2a38b2650d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Simplex Tableau given a set of inequality constraints.  <br /></td></tr>
<tr class="separator:a7d948c25bc5bbe0d1fac2a38b2650d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74b70ee8a196322b4a706ab3236293d" id="r_af74b70ee8a196322b4a706ab3236293d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </td></tr>
<tr class="memitem:af74b70ee8a196322b4a706ab3236293d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#af74b70ee8a196322b4a706ab3236293d">eliminate_objective</a> (Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">tableau</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> std::vector&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">basic_variables</a>)</td></tr>
<tr class="memdesc:af74b70ee8a196322b4a706ab3236293d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Gaussian elimination on the last row of the tableau.  <br /></td></tr>
<tr class="separator:af74b70ee8a196322b4a706ab3236293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2651870dbc8202ea6781c632c9a8627f" id="r_a2651870dbc8202ea6781c632c9a8627f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </td></tr>
<tr class="memitem:a2651870dbc8202ea6781c632c9a8627f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a2651870dbc8202ea6781c632c9a8627f">pivot</a> (Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">tableau</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">entering_variable</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">leaving_variable</a>)</td></tr>
<tr class="memdesc:a2651870dbc8202ea6781c632c9a8627f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a pivot operation between a basic and a non-basic variable.  <br /></td></tr>
<tr class="separator:a2651870dbc8202ea6781c632c9a8627f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459f93236e6ddd0f39d47a76a6de8219" id="r_a459f93236e6ddd0f39d47a76a6de8219"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </td></tr>
<tr class="memitem:a459f93236e6ddd0f39d47a76a6de8219"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a459f93236e6ddd0f39d47a76a6de8219">simplex</a> (Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">tableau</a>, std::vector&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">basic_variables</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">small_number</a>, std::string &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">halt_reason</a>)</td></tr>
<tr class="memdesc:a459f93236e6ddd0f39d47a76a6de8219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform successive pivot operations until a termination condition is met.  <br /></td></tr>
<tr class="separator:a459f93236e6ddd0f39d47a76a6de8219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd7c2b6a96c6f05e574235a88c96b45" id="r_aacd7c2b6a96c6f05e574235a88c96b45"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </td></tr>
<tr class="memitem:aacd7c2b6a96c6f05e574235a88c96b45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#aacd7c2b6a96c6f05e574235a88c96b45">two_steps_method</a> (<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, 1 &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">objective</a>, Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">tableau</a>, std::vector&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">basic_variables</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">unsigned</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">na</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">small_number</a>, std::string &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">halt_reason</a>)</td></tr>
<tr class="memdesc:aacd7c2b6a96c6f05e574235a88c96b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a minimization problem using the two-steps Simplex method.  <br /></td></tr>
<tr class="separator:aacd7c2b6a96c6f05e574235a88c96b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad865f397ee5b5e611f4ea3b56ebf3dae" id="r_ad865f397ee5b5e611f4ea3b56ebf3dae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </td></tr>
<tr class="memitem:ad865f397ee5b5e611f4ea3b56ebf3dae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#ad865f397ee5b5e611f4ea3b56ebf3dae">penalty_method</a> (<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, 1 &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">objective</a>, Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">tableau</a>, std::vector&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> &gt; &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">basic_variables</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">unsigned</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">na</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">small_number</a>, <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">large_number</a>, std::string &amp;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">halt_reason</a>)</td></tr>
<tr class="memdesc:ad865f397ee5b5e611f4ea3b56ebf3dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a minimization problem using the penalty Simplex method.  <br /></td></tr>
<tr class="separator:ad865f397ee5b5e611f4ea3b56ebf3dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility functions used by the Simplex algorithm. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a7d948c25bc5bbe0d1fac2a38b2650d62" name="a7d948c25bc5bbe0d1fac2a38b2650d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d948c25bc5bbe0d1fac2a38b2650d62">&#9670;&#160;</a></span>create_tableau()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">void</a> EigenOpt::simplex::internal::create_tableau </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>basic_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Simplex Tableau given a set of inequality constraints. </p>
<p>This function creates a Simplex Tableau, given a set of inequality constraints in the form \(\bm{C}\bm{x}\leq\bm{d}\) and implicitly assuming that \(\bm{x}\geq\bm{0}\).</p>
<p>The Simplex method works as follows:</p><ul>
<li>For each inequalty such that \(d_i \geq 0\), create a new equality constraint \(\bm{c}_i^T \bm{x} + s_i = d_i\), where \(s_i\geq 0\) is a slack variable.</li>
<li>For each inequalty such that \(d_i &lt; 0\), create a new equality constraint \(-\bm{c}_i^T \bm{x} - s_i + a_i = -d_i\), where \(s_i \geq 0\) is a slack variable and \(a_i \geq 0\) is an artificial variable.</li>
</ul>
<p>The coefficients are gathered in a matrix (the Tableau) with size \((n_v+m+n_a+1, m+1)\) - where \(n_v\) is the number of variables in the original problem, \(m\) is the number of inequality constraints (and of slack variables) and \(n_a\) is the nuber of artificial variables.</p>
<p>The tableau looks as follows:  </p><p class="formulaDsp">
\begin{equation}
\begin{array}{ccc|c}
  \bm{\Sigma}\bm{C} &amp; \bm{\Sigma} &amp; \bm{S} &amp; \bm{\Sigma}\bm{d} \\
  \hline
  \bm{0}^T &amp; \bm{0}^T &amp; \bm{0}^T &amp; 0
\end{array}
\end{equation}
</p>
<p> Where \(\bm{\Sigma}\) is a diagonal matrix such that the i-th diagonal entry equals \(sign(d_i)\). \(\bm{C}\) and \(\bm{d}\) are the original constraints matrix and vector. \(\bm{S}\) is a "selection matrix", such that \(\bm{S}(i,j) = 1\) if the constraint \(i\) includes the artificial variable \(a_j\).</p>
<p>Furthermore, a basis of \(m\) variables (called "basic-variables") is chosen, so that the equality constraints can be expressed as \(\bm{M}*\bm{x}_n + \bm{x}_b = \bm{\delta}\), with \(\bm{x}_b\) the set of basic variables and \(\bm{x}_n\) the set of non-basic variables. In the creation step of the tableau, the basic variables are always the set of artificial variables plus all slack variables \(s_i\) for which \(d_i \geq 0\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>Inequality constraints matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>Inequality constraints vector. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tableau</td><td>Matrix with size \((n_v+m+n_a+1, m+1)\) - it is resized as needed, and all its content erased beforehand. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">basic_variables</td><td>A vector of size \(m\), such that <code>basic_variables[row]</code> tells the index of the active variable for the given row (there is one basic variable per row). It is resized as needed and overwritten. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simplex__internal_8hxx_source.html#l00234">234</a> of file <a class="el" href="simplex__internal_8hxx_source.html">simplex_internal.hxx</a>.</p>

</div>
</div>
<a id="a2d2a61a7c4ba3c3807109a931ed1aee3" name="a2d2a61a7c4ba3c3807109a931ed1aee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2a61a7c4ba3c3807109a931ed1aee3">&#9670;&#160;</a></span>deduce_variables_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">bool</a> EigenOpt::simplex::internal::deduce_variables_domains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>small_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structEigenOpt_1_1simplex_1_1internal_1_1VariableDomain.html">VariableDomain</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>domains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>halt_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of inequality constraints, deduce the domain of the decision variables. </p>
<p>The simplex method operates on positive variables. To overcome this limitation, one can perform the substitution \(x=u-v\), where both \(u\) and \(v\) are positive. However, some constraints may directly limit the domain of a variable. As an example, consider the constraints \(-4x_1 \leq -8\) and \(3*x_2 \leq -12\). They can be simplified to \(x_1\geq 2\) and \(x_2\leq -4\). It must be noted that \(x_1\) cannot be negative, and \(x_2\) cannot be positive. It is therefore not necessary to introduce a couple of variables for each of these. Instead, one could parameterize them just as \(x_1=u_1\) and \(x_2=-v_2\), with \(u_1\geq 0\) and \(v_2\geq 0\). This function scans the constraints and looks for these situations, storing information about the signs a variable can have. It is also able to detect impossible constraints such as pairs like \(x \geq 10\) and \(x \leq -5\), halting immediately the optimization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>Inequality constraints matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>Inequality constraints vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">small_number</td><td>Tolerance to detect near-zero values and trat them as 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">domains</td><td>List of domains - one per variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">halt_reason</td><td>If the function returned false, this message explains why. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if impossible constraints were detected, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simplex__internal_8hxx_source.html#l00014">14</a> of file <a class="el" href="simplex__internal_8hxx_source.html">simplex_internal.hxx</a>.</p>

</div>
</div>
<a id="af74b70ee8a196322b4a706ab3236293d" name="af74b70ee8a196322b4a706ab3236293d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74b70ee8a196322b4a706ab3236293d">&#9670;&#160;</a></span>eliminate_objective()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">void</a> EigenOpt::simplex::internal::eliminate_objective </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> std::vector&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>basic_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use Gaussian elimination on the last row of the tableau. </p>
<p>Given a Tableau, run a Gaussian elimination step to make sure that, for each basic variable, its coefficient in the bottom row becomes 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tableau</td><td>A Simplex Tableau. It must be in a standard form, i.e., for each row exactly one basic variable has its coefficient set to 1 (the other basic variables having coefficient 0 in that row). It will be modified in-place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basic_variables</td><td>List of basic variables, such that <code>basic_variables[row]</code> tells which is the basic variables associated to that row of the Tableau. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simplex__internal_8hxx_source.html#l00287">287</a> of file <a class="el" href="simplex__internal_8hxx_source.html">simplex_internal.hxx</a>.</p>

</div>
</div>
<a id="ad865f397ee5b5e611f4ea3b56ebf3dae" name="ad865f397ee5b5e611f4ea3b56ebf3dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad865f397ee5b5e611f4ea3b56ebf3dae">&#9670;&#160;</a></span>penalty_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">bool</a> EigenOpt::simplex::internal::penalty_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>objective</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>basic_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">unsigned</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a>&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>small_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>large_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>halt_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a minimization problem using the penalty Simplex method. </p>
<p>Given a Tableau in standard form (except for the last row, which should be set to zero), this function will try to simultaneously find the optimum while heavily penalizing constraint infringiment.</p>
<p>The algorithm starts by copying the objective coefficients into the bottom row of the Tableau, and then adding a large penalty to each artificial variable. It then eliminates all weights associated to basic variables to obtain the gradient of the objective function in terms of non-basic variables. Standard pivoting operations are then performed to minimize the value of the artificial variables and of the objective simultaneously. If the solution has at least one non-zero artificial variable, then the problem is infeasible, otherwise an optimum has been found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objective</td><td>Coefficients of the decision variables in the objective function. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tableau</td><td>A Simplex Tableau. It will be modified in-place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>For the algorithm to work as intended, the Tableau must be valid, with the bottom row set to zero. This precondition is not checked and if not respected leads to undefined behavior. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">basic_variables</td><td>List of basic variables. It will be modified in-place. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">na</td><td>Number of artificial variables in the Tableau (the number of working and slack variables will be calculated automatically). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">small_number</td><td>Tolerance to detect near-zero values and trat them as 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">large_number</td><td>Penalty to be given to artificial variables. It should be set to a large enough value, so that setting artificial variables to zero takes the precedence over optimizing the objective. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">halt_reason</td><td>This message explains (human-readable text) why the function returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the problem is infeasible, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simplex__internal_8hxx_source.html#l00428">428</a> of file <a class="el" href="simplex__internal_8hxx_source.html">simplex_internal.hxx</a>.</p>

</div>
</div>
<a id="a2651870dbc8202ea6781c632c9a8627f" name="a2651870dbc8202ea6781c632c9a8627f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2651870dbc8202ea6781c632c9a8627f">&#9670;&#160;</a></span>pivot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">void</a> EigenOpt::simplex::internal::pivot </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a>&#160;</td>
          <td class="paramname"><em>entering_variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a>&#160;</td>
          <td class="paramname"><em>leaving_variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a pivot operation between a basic and a non-basic variable. </p>
<p>Given a Tableau in standard form, this function runs a simple normalization step followed by Gaussian elimination.</p>
<p>The normalization step will divide the target row by the coefficient of the entering variable. It will then use Gaussian elimination to nullify the coefficient of the entering variable in all other rows. The bottom row is not modified by this function, to increase versatility. If needed, one can either call <code><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#af74b70ee8a196322b4a706ab3236293d" title="Use Gaussian elimination on the last row of the tableau.">eliminate_objective()</a></code> after a call to <code><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a2651870dbc8202ea6781c632c9a8627f" title="Perform a pivot operation between a basic and a non-basic variable.">pivot()</a></code> to ensure that all coefficients in the bottom row are processed as expected, or "manually" eliminate the coefficients as needed.</p>
<dl class="section warning"><dt>Warning</dt><dd>For this operation to make sense, the Tableau must start in a valid state, defined by the "rules" of the Simplex method. Furthermore, the coefficient of the entering variable in the target row must be positive. Finally, the entering variable must be part of the non-basic set, and the leaving variable must be part of the basic set. These preconditions are not checked in this function and if not satisfied will lead to undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tableau</td><td>A Simplex Tableau. It will be modified in-place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entering_variable</td><td>Index of the non-basic variable that will enter the basic set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leaving_variable</td><td>Index of the basic variable that will leave the basic set. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="simplex__internal_8hxx_source.html#l00153">153</a> of file <a class="el" href="simplex__internal_8hxx_source.html">simplex_internal.hxx</a>.</p>

</div>
</div>
<a id="a459f93236e6ddd0f39d47a76a6de8219" name="a459f93236e6ddd0f39d47a76a6de8219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459f93236e6ddd0f39d47a76a6de8219">&#9670;&#160;</a></span>simplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">bool</a> EigenOpt::simplex::internal::simplex </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>basic_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>small_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>halt_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform successive pivot operations until a termination condition is met. </p>
<p>Given a Tableau in standard form, this function will perform a series of pivot operations to minimize the associated objective.</p>
<p>At each iteration, the entering and leaving variables are selected according to the rules of the Simplex method:</p><ul>
<li>The entering variable is the one whose coefficient in the bottom row is the most negative one.</li>
<li>The leaving variable is the one for which the ratio between the coefficient in the rightmost column and the one in the entering column is the smallest positive one. If no entering variable can be found (because all coefficients are non-negative), an optimal solution has been found. If no leaving variable can be determined (because all coefficients in the entering column are non-positive) then the problem is unbounded.</li>
</ul>
<p>After selection of the pivoting variables, a Gaussian elimination step has to be performed to set to zero all coefficients in the entering column except that of the leaving row (which will be normalized to 1).</p>
<p>The two steps (selection of the pivoting variables and Gaussian elimination) are performed in succession until a termination condition has been found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tableau</td><td>A Simplex Tableau. It will be modified in-place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>For the algorithm to work as intended, the Tableau must be valid and already in its reduced form. This precondition is not checked and if not respected leads to undefined behavior. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">basic_variables</td><td>List of basic variables. It will be modified in-place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">small_number</td><td>Tolerance to detect near-zero values and trat them as 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">halt_reason</td><td>This message explains (human-readable text) why the function returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the problem is unbounded, true if the Simplex method halted successfully. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simplex__internal_8hxx_source.html#l00175">175</a> of file <a class="el" href="simplex__internal_8hxx_source.html">simplex_internal.hxx</a>.</p>

</div>
</div>
<a id="a7c008fc16c1272793272a84be35eb851" name="a7c008fc16c1272793272a84be35eb851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c008fc16c1272793272a84be35eb851">&#9670;&#160;</a></span>transformation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">bool</a> EigenOpt::simplex::internal::transformation_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>small_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>halt_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a transformation matrix so that \(\bm{x}=\bm{T}\bm{w}\), \(w \geq 0\). </p>
<p>This function is a convenience that chains a call to <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a2d2a61a7c4ba3c3807109a931ed1aee3" title="Given a set of inequality constraints, deduce the domain of the decision variables.">deduce_variables_domains()</a> and <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2" title="Calculate a transformation matrix so that , .">transformation_matrix_from_domains()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a2d2a61a7c4ba3c3807109a931ed1aee3" title="Given a set of inequality constraints, deduce the domain of the decision variables.">deduce_variables_domains()</a> </dd>
<dd>
<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2" title="Calculate a transformation matrix so that , .">transformation_matrix_from_domains()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>Inequality constraints matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>Inequality constraints vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">small_number</td><td>Tolerance to detect near-zero values and trat them as 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>Transformation matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">halt_reason</td><td>If the function returned false, this message explains why. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if impossible constraints were detected, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simplex__internal_8hxx_source.html#l00130">130</a> of file <a class="el" href="simplex__internal_8hxx_source.html">simplex_internal.hxx</a>.</p>

</div>
</div>
<a id="a023f64ee8724d3702a37a25cbac476e2" name="a023f64ee8724d3702a37a25cbac476e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023f64ee8724d3702a37a25cbac476e2">&#9670;&#160;</a></span>transformation_matrix_from_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; EigenOpt::simplex::internal::transformation_matrix_from_domains </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structEigenOpt_1_1simplex_1_1internal_1_1VariableDomain.html">VariableDomain</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>domains</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a transformation matrix so that \(\bm{x}=\bm{T}\bm{w}\), \(w \geq 0\). </p>
<p>Decision variables can be parameterized as either: \(x=u-v\), \(x=u\) or \(x=-v\), with \(u\geq 0\) and \(v\geq 0\). When parameterizing multiple variables, it is convenient to express all transformations at once using a matrix \(\bm{T}\). As an example, consider \(x_1=-v_1\), \(x_2=u_2-v2\) and \(x_3=u_3-v_3\). The parameterization can be written in matrix form as \(\bm{x} = \bm{T}\bm{w}\):  </p><p class="formulaDsp">
\begin{equation}
\begin{bmatrix} x_1 \\ x_2 \\ x_3 \end{bmatrix}
\begin{bmatrix}
  -1 &amp;   &amp;    &amp;   &amp;    \\
     &amp; 1 &amp; -1 &amp;   &amp;    \\
     &amp;   &amp;    &amp; 1 &amp; -1 \\
\end{bmatrix}
\begin{bmatrix} v_1 \\ u_2 \\ v_2 \\ u_3 \\ v_3 \end{bmatrix}
\end{equation}
</p>
<p>This function computes the transformation matrix \(\bm{T}\).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Type used for calculations in Eigen matrices and vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domains</td><td>List of variable domains, telling how each variable should be expressed among the three alternatives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix \(\bm{T}\). </dd></dl>

<p class="definition">Definition at line <a class="el" href="simplex__internal_8hxx_source.html#l00083">83</a> of file <a class="el" href="simplex__internal_8hxx_source.html">simplex_internal.hxx</a>.</p>

</div>
</div>
<a id="aacd7c2b6a96c6f05e574235a88c96b45" name="aacd7c2b6a96c6f05e574235a88c96b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd7c2b6a96c6f05e574235a88c96b45">&#9670;&#160;</a></span>two_steps_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">class</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">bool</a> EigenOpt::simplex::internal::two_steps_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>objective</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>tableau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>basic_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">unsigned</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">int</a>&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">const</a> <a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html#a023f64ee8724d3702a37a25cbac476e2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>small_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>halt_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a minimization problem using the two-steps Simplex method. </p>
<p>Given a Tableau in standard form (except for the last row, which should be set to zero), this function will first try to find a feasible point that satisfies all inequality constraints and then perform successive pivot operations to reach an optimal solution.</p>
<p>The algorithm starts by adding a unit weight to each artificial variable, then eliminating all weights to obtain the gradient of the objective function in terms of non-basic variables. Standard pivoting operations are then performed to minimize the value of the artificial variables. If the solution has at least one non-zero artificial variable, then the problem is infeasible and the function returns.</p>
<p>If after the first step all artificial variables are set to zero, the algorithm checks if any artificial variable is still in the active set. If that is the case, it swaps them with non-basic, non-artificial ones. Artificial variables are then removed from the Tableau entirely. The objective coefficients are then copied into the bottom row of the Tableau, and a step of Gaussian elimination is performed to ensure that the Tableau is in standard form. Pivoting is then performed until the problem is solved or found to be unbounded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objective</td><td>Coefficients of the decision variables in the objective function. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tableau</td><td>A Simplex Tableau. It will be modified in-place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>For the algorithm to work as intended, the Tableau must be valid, with the bottom row set to zero. This precondition is not checked and if not respected leads to undefined behavior. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">basic_variables</td><td>List of basic variables. It will be modified in-place. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">na</td><td>Number of artificial variables in the Tableau (the number of working and slack variables will be calculated automatically). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">small_number</td><td>Tolerance to detect near-zero values and trat them as 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">halt_reason</td><td>This message explains (human-readable text) why the function returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the problem is infeasible, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simplex__internal_8hxx_source.html#l00302">302</a> of file <a class="el" href="simplex__internal_8hxx_source.html">simplex_internal.hxx</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigenOpt.html">EigenOpt</a></li><li class="navelem"><a class="el" href="namespaceEigenOpt_1_1simplex.html">simplex</a></li><li class="navelem"><a class="el" href="namespaceEigenOpt_1_1simplex_1_1internal.html">internal</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
